import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.YPpNXepj.js";const g=JSON.parse('{"title":"React 原理","description":"","frontmatter":{},"headers":[],"relativePath":"docs/second-exam/react-inner.md","filePath":"docs/second-exam/react-inner.md"}'),l={name:"docs/second-exam/react-inner.md"};function e(p,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="react-原理" tabindex="-1">React 原理 <a class="header-anchor" href="#react-原理" aria-label="Permalink to &quot;React 原理&quot;">​</a></h1><p>国内面试，大厂必考原理。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>目标<strong>不在</strong>中大厂的同学，可以略过这一节。</li><li>对 React 使用尚不熟练的同学，不要在此花费太多精力，先熟悉使用再说。</li></ol></div><h2 id="jsx-的本质是什么" tabindex="-1">JSX 的本质是什么？ <a class="header-anchor" href="#jsx-的本质是什么" aria-label="Permalink to &quot;JSX 的本质是什么？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p><strong>JSX（JavaScript XML）</strong> 是一个 JavaScript 的语法扩展，允许在 JavaScript 代码中通过类 HTML 语法创建 React 元素。它需要通过 Babel 等工具编译为标准的 JavaScript 代码，最终生成 <strong>React 元素对象</strong>（React Element），这些元素共同构成虚拟 DOM（Virtual DOM）树。</p><p><strong>核心原理</strong></p><ol><li><p><strong>JSX 编译为 React 元素</strong><br> JSX 会被转换为 <code>React.createElement()</code> 调用（或 React 17+ 的 <code>_jsx</code> 函数），生成描述 UI 结构的对象（React 元素），而非直接操作真实 DOM。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, world!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（React 17 之前）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;title&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, world!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（React 17+，自动引入 _jsx）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { jsx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _jsx } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react/jsx-runtime&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _jsx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;title&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, world!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div></li><li><p><strong>虚拟 DOM 的运作</strong></p><ul><li>React 元素组成虚拟 DOM 树，通过 Diff 算法对比新旧树差异，最终高效更新真实 DOM。</li><li>虚拟 DOM 是内存中的轻量对象，避免频繁操作真实 DOM 的性能损耗。</li></ul></li></ol><p><strong>JSX 的核心特性</strong></p><ol><li><p><strong>类 HTML 语法与 JavaScript 的融合</strong></p><ul><li><strong>表达式嵌入</strong>：通过 <code>{}</code> 嵌入 JavaScript 表达式（如变量、函数调用、三元运算符）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Alice&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {userName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><strong>禁止语句</strong>：<code>{}</code> 内不支持 <code>if</code>/<code>for</code> 等语句，需改用表达式（如三元运算符或逻辑与）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{isLoggedIn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Welcome&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Please Login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul></li><li><p><strong>语法规则</strong></p><ul><li><strong>属性命名</strong>：使用驼峰命名（如 <code>className</code> 代替 <code>class</code>，<code>htmlFor</code> 代替 <code>for</code>）。</li><li><strong>闭合标签</strong>：所有标签必须显式闭合（如 <code>&lt;img /&gt;</code>）。</li><li><strong>单一根元素</strong>：JSX 必须有唯一根元素（或用 <code>&lt;&gt;&lt;/&gt;</code> 空标签包裹）。</li></ul></li><li><p><strong>安全性</strong></p><ul><li><strong>默认 XSS 防护</strong>：JSX 自动转义嵌入内容中的特殊字符（如 <code>&lt;</code> 转为 <code>&amp;lt;</code>）。</li><li><strong>例外场景</strong>：如需渲染原始 HTML，需显式使用 <code>dangerouslySetInnerHTML</code>（需谨慎）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dangerouslySetInnerHTML</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ __html: userContent }} /&gt;</span></span></code></pre></div></li></ul></li></ol><p><strong>编译与工具链</strong></p><ol><li><p><strong>编译流程</strong><br> JSX 需通过 <strong>Babel</strong> 编译为浏览器可执行的 JavaScript。典型配置如下：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// .babelrc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;presets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>React 17+ 的优化</strong></p><ul><li>无需手动导入 React：编译器自动引入 <code>_jsx</code> 函数。</li><li>更简洁的编译输出：减少代码体积，提升可读性。</li></ul></li></ol></details><h2 id="如何理解-react-fiber-架构" tabindex="-1">如何理解 React Fiber 架构？ <a class="header-anchor" href="#如何理解-react-fiber-架构" aria-label="Permalink to &quot;如何理解 React Fiber 架构？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>Fiber 架构的本质与设计目标</strong></li></ol><p>Fiber 是 React 16+ 的<strong>核心算法重写</strong>，本质是<strong>基于链表的增量式协调模型</strong>。其核心目标并非单纯提升性能，而是重构架构以实现：</p><ul><li><strong>可中断的异步渲染</strong>：将同步递归的调和过程拆解为可暂停/恢复的异步任务。</li><li><strong>优先级调度</strong>：高优先级任务（如用户输入）可打断低优先级任务（如数据更新）。</li><li><strong>并发模式基础</strong>：为 <code>Suspense</code>、<code>useTransition</code> 等特性提供底层支持。</li></ul><ol start="2"><li><strong>Fiber 节点的核心设计</strong></li></ol><p>每个组件对应一个 <strong>Fiber 节点</strong>，构成<strong>双向链表树结构</strong>，包含以下关键信息：</p><ul><li><strong>组件类型</strong>：函数组件、类组件或原生标签。</li><li><strong>状态与副作用</strong>：Hooks 状态（如 <code>useState</code>）、生命周期标记（如 <code>useEffect</code>）。</li><li><strong>调度信息</strong>：任务优先级（<code>lane</code> 模型）、到期时间（<code>expirationTime</code>）。</li><li><strong>链表指针</strong>：<code>child</code>（子节点）、<code>sibling</code>（兄弟节点）、<code>return</code>（父节点）。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fiber 节点结构简化示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: FunctionComponent, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stateNode: ComponentFunc, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件实例或 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Hooks 链表 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pendingProps: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 待处理 props */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lanes: Lanes.HighPriority, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任务优先级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  child: nextFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sibling: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 兄弟节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return: parentFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li><strong>Fiber 协调流程（两阶段提交）</strong></li></ol><p><strong>阶段 1：Reconciliation（协调/渲染阶段）</strong></p><ul><li><strong>可中断的增量计算</strong>：<br> React 将组件树遍历拆解为多个 <strong>Fiber 工作单元</strong>，通过循环（而非递归）逐个处理。 <ul><li>每次循环执行一个 Fiber 节点，生成子 Fiber 并连接成树。</li><li>通过 <code>requestIdleCallback</code>（或 Scheduler 包）在浏览器空闲时段执行，避免阻塞主线程。</li></ul></li><li><strong>对比策略</strong>：<br> 根据 <code>key</code> 和 <code>type</code> 复用节点，标记 <code>Placement</code>（新增）、<code>Update</code>（更新）、<code>Deletion</code>（删除）等副作用。</li></ul><p><strong>阶段 2：Commit（提交阶段）</strong></p><ul><li><strong>不可中断的 DOM 更新</strong>：<br> 同步执行所有标记的副作用（如 DOM 操作、生命周期调用），确保 UI 一致性。</li><li><strong>副作用分类</strong>： <ul><li><strong>BeforeMutation</strong>：<code>getSnapshotBeforeUpdate</code>。</li><li><strong>Mutation</strong>：DOM 插入/更新/删除。</li><li><strong>Layout</strong>：<code>useLayoutEffect</code>、<code>componentDidMount</code>/<code>Update</code>。</li></ul></li></ul><ol start="4"><li><strong>优先级调度机制</strong></li></ol><p>React 通过 <strong>Lane 模型</strong> 管理任务优先级（共 31 个优先级车道）：</p><ul><li><strong>事件优先级</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优先级从高到低</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ImmediatePriority（用户输入）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UserBlockingPriority（悬停、点击）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NormalPriority（数据请求）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LowPriority（分析日志）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IdlePriority（非必要任务）</span></span></code></pre></div></li><li><strong>调度策略</strong>： <ul><li>高优先级任务可抢占低优先级任务的执行权。</li><li>过期任务（如 Suspense 回退）会被强制同步执行。</li></ul></li></ul><ol start="5"><li><strong>Fiber 架构的优势与局限性</strong></li></ol><p><strong>优势</strong></p><ul><li><strong>流畅的用户体验</strong>：异步渲染避免主线程阻塞，保障高优先级任务即时响应。</li><li><strong>复杂场景优化</strong>：支持大规模组件树的高效更新（如虚拟滚动、动画串联）。</li><li><strong>未来特性基础</strong>：为并发模式（Concurrent Mode）、离线渲染（SSR）提供底层支持。</li></ul><p><strong>局限性</strong></p><ul><li><strong>学习成本高</strong>：开发者需理解底层调度逻辑以优化性能。</li><li><strong>内存开销</strong>：Fiber 树的双向链表结构比传统虚拟 DOM 占用更多内存。</li></ul><ol start="6"><li><strong>与旧架构的关键差异</strong></li></ol><table tabindex="0"><thead><tr><th>特性</th><th>Stack Reconciler（React 15-）</th><th>Fiber Reconciler（React 16+）</th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>递归（不可中断）</td><td>循环（可中断 + 恢复）</td></tr><tr><td><strong>任务调度</strong></td><td>同步执行，阻塞主线程</td><td>异步分片，空闲时段执行</td></tr><tr><td><strong>优先级控制</strong></td><td>无</td><td>基于 Lane 模型的优先级抢占</td></tr><tr><td><strong>数据结构</strong></td><td>虚拟 DOM 树</td><td>Fiber 链表树（含调度信息）</td></tr></tbody></table></details><h2 id="fiber-结构和普通-vnode-有什么区别" tabindex="-1">Fiber 结构和普通 VNode 有什么区别？ <a class="header-anchor" href="#fiber-结构和普通-vnode-有什么区别" aria-label="Permalink to &quot;Fiber 结构和普通 VNode 有什么区别？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>本质差异</strong></li></ol><table tabindex="0"><thead><tr><th>维度</th><th>普通 VNode（虚拟 DOM）</th><th>Fiber 结构</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>减少真实 DOM 操作，提升渲染性能</td><td>实现可中断的异步渲染 + 优先级调度</td></tr><tr><td><strong>数据结构</strong></td><td>树形结构（递归遍历）</td><td>双向链表树（循环遍历）</td></tr><tr><td><strong>功能范畴</strong></td><td>仅描述 UI 结构</td><td>描述 UI 结构 + 调度任务 + 副作用管理</td></tr></tbody></table><ol start="2"><li><strong>数据结构对比</strong></li></ol><p><strong>普通 VNode（React 15 及之前）</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类型（组件/原生标签）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  children: [vNode1, vNode2], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点（树形结构）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unique-id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优化 Diff 性能</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 无状态、调度、副作用信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>核心字段</strong>：仅包含 UI 描述相关属性（type、props、children）。</li></ul><p><strong>Fiber 节点（React 16+）</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: HostComponent, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类型（函数组件/类组件/DOM元素）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原生标签或组件构造函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unique-id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Diff 优化标识</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stateNode: domNode, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 关联的真实 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pendingProps: { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 待处理的 props</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedProps: {}, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 已生效的 props</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Hooks 状态（函数组件）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hooks: [state1, effectHook],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  updateQueue: [], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态更新队列（类组件）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lanes: Lanes.HighPriority, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调度优先级（Lane 模型）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  child: childFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sibling: siblingFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 下一个兄弟节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return: parentFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父节点（构成双向链表）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  effectTag: Placement, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用标记（插入/更新/删除）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nextEffect: nextEffectFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用链表指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>核心扩展</strong>： <ul><li><strong>调度控制</strong>：<code>lanes</code> 优先级、任务到期时间。</li><li><strong>状态管理</strong>：Hooks 链表（函数组件）、类组件状态队列。</li><li><strong>副作用追踪</strong>：<code>effectTag</code> 标记和副作用链表。</li><li><strong>遍历结构</strong>：<code>child</code>/<code>sibling</code>/<code>return</code> 构成双向链表。</li></ul></li></ul><ol start="3"><li><strong>协调机制对比</strong></li></ol><table tabindex="0"><thead><tr><th>流程</th><th>VNode（Stack Reconciler）</th><th>Fiber Reconciler</th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>递归遍历（不可中断）</td><td>循环遍历链表（可中断 + 恢复）</td></tr><tr><td><strong>任务调度</strong></td><td>同步执行，阻塞主线程</td><td>异步分片，空闲时间执行</td></tr><tr><td><strong>优先级控制</strong></td><td>无</td><td>Lane 模型（31 个优先级车道）</td></tr><tr><td><strong>副作用处理</strong></td><td>统一提交 DOM 更新</td><td>构建副作用链表，分阶段提交</td></tr></tbody></table><ul><li><strong>Fiber 两阶段提交</strong>： <ol><li><strong>协调阶段</strong>（可中断）： <ul><li>增量构建 Fiber 树，标记副作用（<code>effectTag</code>）。</li><li>通过 <code>requestIdleCallback</code> 或 Scheduler 包分片执行。</li></ul></li><li><strong>提交阶段</strong>（同步不可中断）： <ul><li>遍历副作用链表，执行 DOM 操作和生命周期方法。</li></ul></li></ol></li></ul><ol start="4"><li><p><strong>能力扩展示例</strong></p><p><strong>a. 支持 Hooks 状态管理</strong></p></li></ol><ul><li>Fiber 节点通过 <code>memoizedState</code> 字段存储 Hooks 链表：</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数组件的 Hooks 链表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fiberNode.memoizedState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;state value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useState 的状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 下一个 Hook（如 useEffect）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    memoizedState: { cleanup: fn },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    next: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>VNode 无状态管理能力，仅描述 UI。</li></ul><p><strong>b. 优先级调度实战</strong></p><ul><li><strong>高优先级任务抢占</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户输入触发高优先级更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setInputValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target.value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 低优先级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 高优先级更新立即执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li>VNode 架构无法实现任务中断和优先级插队。</li></ul><p><strong>c. 副作用批处理</strong></p><ul><li>Fiber 通过 <code>effectList</code> 链表收集所有变更，统一提交：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 提交阶段遍历 effectList</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fiberRoot.firstEffect</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextEffect) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  commitWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextEffect)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nextEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextEffect.nextEffect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li>VNode 架构在 Diff 后直接操作 DOM，无批处理优化。</li></ul><ol start="5"><li><strong>性能影响对比</strong></li></ol><table tabindex="0"><thead><tr><th>场景</th><th>VNode 架构</th><th>Fiber 架构</th></tr></thead><tbody><tr><td><strong>大型组件树渲染</strong></td><td>主线程阻塞导致掉帧</td><td>分片渲染，保持 UI 响应</td></tr><tr><td><strong>高频更新（如动画）</strong></td><td>多次渲染合并困难</td><td>基于优先级合并或跳过中间状态</td></tr><tr><td><strong>SSR 水合（Hydration）</strong></td><td>全量同步处理</td><td>增量水合，优先交互部分</td></tr></tbody></table></details><h2 id="简述-react-diff-算法过程" tabindex="-1">简述 React diff 算法过程 <a class="header-anchor" href="#简述-react-diff-算法过程" aria-label="Permalink to &quot;简述 React diff 算法过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React Diff 算法通过 <strong>分层对比策略</strong> 和 <strong>启发式规则</strong> 减少树对比的时间复杂度（从 O(n³) 优化至 O(n)）。其核心流程如下：</p><p><strong>1. 分层对比策略</strong></p><p>React 仅对 <strong>同一层级的兄弟节点</strong> 进行对比，若节点跨层级移动（如从父节点 A 移动到父节点 B），则直接 <strong>销毁并重建</strong>，而非移动。<br><strong>原因</strong>：跨层操作在真实 DOM 中成本极高（需递归遍历子树），而实际开发中跨层移动场景极少，此策略以概率换性能。</p><p><strong>2. 节点类型比对规则</strong></p><p><strong>a. 元素类型不同</strong></p><p>若新旧节点类型不同（如 <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code> 或 <code>ComponentA</code> → <code>ComponentB</code>），则：</p><ol><li>销毁旧节点及其子树。</li><li>创建新节点及子树，并插入 DOM。</li></ol><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧树</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ComponentA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新树 → 直接替换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ComponentB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>b. 元素类型相同</strong></p><p>若类型相同，则复用 DOM 节点并更新属性：</p><ul><li><strong>原生标签</strong>：更新 <code>className</code>、<code>style</code> 等属性。</li><li><strong>组件类型</strong>： <ul><li>类组件：保留实例，触发 <code>componentWillReceiveProps</code> → <code>shouldComponentUpdate</code> 等生命周期。</li><li>函数组件：重新执行函数，通过 Hooks 状态判断是否需更新。</li></ul></li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧组件（保留实例并更新 props）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;old&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleClick} /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新组件 → 复用 DOM，更新 className 和 onClick</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{newClick} /&gt;</span></span></code></pre></div><p><strong>3. 列表节点的 Key 优化</strong></p><p>处理子节点列表时，React 依赖 <strong>key</strong> 进行最小化更新：</p><p><strong>a. 无 key 时的默认行为</strong></p><p>默认使用 <strong>索引匹配</strong>（index-based diff），可能导致性能问题：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;[&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;A&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;B&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;][</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 新列表（首部插入）→ 索引对比导致 B 被误判更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ((&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;C&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;), (&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;A&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;), (&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;B&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>此时 React 会认为索引 0 从 A → C（更新），索引 1 从 B → A（更新），并新增索引 2 的 B，实际应仅插入 C。</p><p><strong>b. 使用 key 的优化匹配</strong></p><p>通过唯一 key 标识节点身份，React 可精准识别移动/新增/删除：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正确使用 key（如数据 ID）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id}&gt;{item.text}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>匹配规则</strong>：</p><ol><li><p>遍历新列表，通过 key 查找旧节点：</p><ul><li>找到且类型相同 → 复用节点。</li><li>未找到 → 新建节点。</li></ul></li><li><p>记录旧节点中未被复用的节点 → 执行删除。</p></li></ol><p><strong>c. 节点移动优化</strong></p><p>若新旧列表节点仅顺序变化，React 通过 key 匹配后，仅执行 <strong>DOM 移动操作</strong>（非重建），例如：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：A (key=1), B (key=2)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：B (key=2), A (key=1)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 仅交换 DOM 顺序，而非销毁重建</span></span></code></pre></div><p><strong>4. 性能边界策略</strong></p><ul><li><strong>子树跳过</strong>：若父节点类型变化，其子节点即使未变化也会被整体销毁。</li><li><strong>相同组件提前终止</strong>：若组件 <code>shouldComponentUpdate</code> 返回 <code>false</code>，则跳过其子树 Diff。</li></ul></details><h2 id="简述-react-和-vue-diff-算法的区别" tabindex="-1">简述 React 和 Vue diff 算法的区别 <a class="header-anchor" href="#简述-react-和-vue-diff-算法的区别" aria-label="Permalink to &quot;简述 React 和 Vue diff 算法的区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 和 Vue 的 Diff 算法均基于虚拟 DOM，但在实现策略、优化手段和设计哲学上存在显著差异：</p><p><strong>1. 核心算法策略对比</strong></p><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>React</strong></th><th><strong>Vue 2/3</strong></th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>单向递归（同层顺序对比）</td><td>双端对比（头尾指针优化）</td></tr><tr><td><strong>节点复用</strong></td><td>类型相同则复用，否则销毁重建</td><td>类型相同则尝试复用，优先移动而非重建</td></tr><tr><td><strong>静态优化</strong></td><td>需手动优化（如 <code>React.memo</code>）</td><td>编译阶段自动标记静态节点</td></tr><tr><td><strong>更新粒度</strong></td><td>组件级更新（默认）</td><td>组件级 + 块级（Vue3 Fragments）</td></tr></tbody></table><p><strong>2. 列表 Diff 实现细节</strong></p><p><strong>a. React 的索引对比策略</strong></p><ul><li><strong>无 key 时</strong>：按索引顺序对比，可能导致无效更新<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：[A, B, C]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：[D, A, B, C]（插入头部）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 对比结果：更新索引 0-3，性能低下</span></span></code></pre></div></li><li><strong>有 key 时</strong>：通过 key 匹配节点，减少移动操作<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// key 匹配后，仅插入 D，其他节点不更新</span></span></code></pre></div></li></ul><p><strong>b. Vue 的双端对比策略</strong></p><p>分四步优化对比效率（Vue2 核心逻辑，Vue3 优化为最长递增子序列）：</p><ol><li><strong>头头对比</strong>：新旧头指针节点相同则复用，指针后移</li><li><strong>尾尾对比</strong>：新旧尾指针节点相同则复用，指针前移</li><li><strong>头尾交叉对比</strong>：旧头 vs 新尾，旧尾 vs 新头</li><li><strong>中间乱序对比</strong>：建立 key-index 映射表，复用可匹配节点</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：[A, B, C, D]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：[D, A, B, C]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 通过步骤3头尾对比，仅移动 D 到头部</span></span></code></pre></div><p><strong>3. 静态优化机制</strong></p><p><strong>a. Vue 的编译时优化</strong></p><ul><li><p><strong>静态节点标记</strong>：<br> 模板中的静态节点（无响应式绑定）会被编译为常量，跳过 Diff</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 编译前 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello Vue&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 编译后 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_hoisted_1 = createVNode(&quot;div&quot;, null, &quot;Hello Vue&quot;)</span></span></code></pre></div></li><li><p><strong>Block Tree（Vue3）</strong>：<br> 动态节点按区块（Block）组织，Diff 时仅对比动态部分</p></li></ul><p><strong>b. React 的运行时优化</strong></p><ul><li><strong>手动控制更新</strong>：<br> 需通过 <code>React.memo</code>、<code>shouldComponentUpdate</code> 或 <code>useMemo</code> 避免无效渲染<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MemoComp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Static Content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span></code></pre></div></li></ul><p><strong>4. 响应式更新触发</strong></p><table tabindex="0"><thead><tr><th><strong>框架</strong></th><th><strong>机制</strong></th><th><strong>Diff 触发条件</strong></th></tr></thead><tbody><tr><td>React</td><td>状态变化触发组件重新渲染</td><td>父组件渲染 → 子组件默认递归 Diff</td></tr><tr><td>Vue</td><td>响应式数据变更触发组件更新</td><td>依赖收集 → 仅受影响组件触发 Diff</td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue：只有 data.value 变化才会触发更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ data: { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React：需显式调用 setState</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>5. 设计哲学差异</strong></p><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>React</strong></th><th><strong>Vue</strong></th></tr></thead><tbody><tr><td><strong>控制粒度</strong></td><td>组件级控制（开发者主导）</td><td>细粒度依赖追踪（框架主导）</td></tr><tr><td><strong>优化方向</strong></td><td>运行时优化（Fiber 调度）</td><td>编译时优化（模板静态分析）</td></tr><tr><td><strong>适用场景</strong></td><td>大型动态应用（需精细控制）</td><td>中小型应用（快速开发）</td></tr></tbody></table></details><h2 id="为何-react-jsx-循环需要使用-key" tabindex="-1">为何 React JSX 循环需要使用 <code>key</code> ？ <a class="header-anchor" href="#为何-react-jsx-循环需要使用-key" aria-label="Permalink to &quot;为何 React JSX 循环需要使用 \`key\` ？&quot;">​</a></h2><p>@雨夜 将于 2025.02.21 之前提交答案。</p><h2 id="react-事件和-dom-事件有什么区别" tabindex="-1">React 事件和 DOM 事件有什么区别？ <a class="header-anchor" href="#react-事件和-dom-事件有什么区别" aria-label="Permalink to &quot;React 事件和 DOM 事件有什么区别？&quot;">​</a></h2><p>合成事件</p><p>@雨夜 将于 2025.02.21 之前提交答案。</p><h2 id="简述-react-batchupdate-机制" tabindex="-1">简述 React batchUpdate 机制 <a class="header-anchor" href="#简述-react-batchupdate-机制" aria-label="Permalink to &quot;简述 React batchUpdate 机制&quot;">​</a></h2><p>@雨夜 将于 2025.02.21 之前提交答案。</p><h2 id="简述-react-事务机制" tabindex="-1">简述 React 事务机制 <a class="header-anchor" href="#简述-react-事务机制" aria-label="Permalink to &quot;简述 React 事务机制&quot;">​</a></h2><p>@雨夜 将于 2025.02.21 之前提交答案。</p><h2 id="如何理解-react-concurrency-并发机制" tabindex="-1">如何理解 React concurrency 并发机制 <a class="header-anchor" href="#如何理解-react-concurrency-并发机制" aria-label="Permalink to &quot;如何理解 React concurrency 并发机制&quot;">​</a></h2><p>@雨夜 将于 2025.02.21 之前提交答案。</p><h2 id="简述-react-reconciliation-协调的过程" tabindex="-1">简述 React reconciliation 协调的过程 <a class="header-anchor" href="#简述-react-reconciliation-协调的过程" aria-label="Permalink to &quot;简述 React reconciliation 协调的过程&quot;">​</a></h2><h2 id="react-组件渲染和更新的全过程" tabindex="-1">React 组件渲染和更新的全过程 <a class="header-anchor" href="#react-组件渲染和更新的全过程" aria-label="Permalink to &quot;React 组件渲染和更新的全过程&quot;">​</a></h2><h2 id="为何-react-hooks-不能放在条件或循环之内" tabindex="-1">为何 React Hooks 不能放在条件或循环之内？ <a class="header-anchor" href="#为何-react-hooks-不能放在条件或循环之内" aria-label="Permalink to &quot;为何 React Hooks 不能放在条件或循环之内？&quot;">​</a></h2>`,32)]))}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
