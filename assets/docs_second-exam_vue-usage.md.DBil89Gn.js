import{_ as i,c as e,a2 as a,o as t}from"./chunks/framework.YPpNXepj.js";const k=JSON.parse('{"title":"Vue 使用","description":"","frontmatter":{},"headers":[],"relativePath":"docs/second-exam/vue-usage.md","filePath":"docs/second-exam/vue-usage.md"}'),n={name:"docs/second-exam/vue-usage.md"};function l(o,s,h,r,d,p){return t(),e("div",null,s[0]||(s[0]=[a(`<h1 id="vue-使用" tabindex="-1">Vue 使用 <a class="header-anchor" href="#vue-使用" aria-label="Permalink to &quot;Vue 使用&quot;">​</a></h1><p>Vue 是国内最普及的前端框架，面试考察概率最高。</p><blockquote><p>官网地址:<a href="https://cn.vuejs.org/" target="_blank" rel="noreferrer">https://cn.vuejs.org/</a></p></blockquote><h2 id="🔥vue3-和-vue2-的区别有哪些-说几个主要的" tabindex="-1">🔥Vue3 和 Vue2 的区别有哪些？说几个主要的 <a class="header-anchor" href="#🔥vue3-和-vue2-的区别有哪些-说几个主要的" aria-label="Permalink to &quot;🔥Vue3 和 Vue2 的区别有哪些？说几个主要的&quot;">​</a></h2><p>Vue 3 提供了更现代化、更高性能的架构，通过 <code>Composition API</code> 和 <code>Proxy</code> 响应式系统等改进提升了开发体验 🎉🎉🎉。相比于 Vue 2，它的优势如下:</p><details class="details custom-block"><summary>参考答案</summary><p><strong>性能优化</strong></p><ul><li><p><strong>虚拟 DOM 重构</strong>：Vue3的虚拟DOM采用了更高效的 <code>Diff算法</code>，减少了渲染和更新的开销。</p></li><li><p><strong>Tree-shaking 支持</strong>：Vue3的代码结构模块化，支持按需引入，减小了打包体积。</p></li></ul><p><strong>Composition API</strong></p><ul><li><p>Vue3引入了Composition API，使代码更模块化、复用性更强。</p></li><li><p>使用 <code>setup()</code> 方法代替了部分选项式 API，通过函数的方式组织逻辑，代码更加清晰简洁。</p></li></ul><p><strong>响应式系统改进</strong></p><ul><li>Vue3使用 <code>Proxy</code> 实现响应式，解决了 Vue2使用Object.defineProperty实现响应式的一些局限性，如无法监听新增属性和数组索引变化。</li></ul><p><strong>新特性和改进</strong></p><ul><li><p><strong>Teleport</strong>：可以将组件的DOM渲染到指定的DOM节点之外，例如模态框、通知等。</p></li><li><p><strong>Fragment 支持</strong>：Vue3支持组件返回多个根节点，不再需要单一根节点。</p></li><li><p>Vue3原生支持 <code>TypeScript</code>，提供更完善的类型推导和开发体验。</p></li><li><p>Vue3支持为一个组件绑定多个 <code>v-model</code>，并且可以自定义 <code>prop</code> 和 <code>event</code> 名称。</p></li></ul></details><h2 id="🔥vue-组件的通讯方式有哪些" tabindex="-1">🔥Vue 组件的通讯方式有哪些？ <a class="header-anchor" href="#🔥vue-组件的通讯方式有哪些" aria-label="Permalink to &quot;🔥Vue 组件的通讯方式有哪些？&quot;">​</a></h2><p>组件之间的通讯通常分为父子组件通讯和跨组件通讯。要注意，vue3 组件的通讯方式和 vue2 有一定的区别。</p><details class="details custom-block"><summary>参考答案</summary><p><strong>父子组件通信</strong></p><ul><li>Props：父组件通过 <code>props</code> 向子组件传递数据。</li><li>$emit：子组件通过 <code>$emit</code> 向父组件发送事件，并可以传递数据。</li><li>获取组件实例对象，调用属性或方法：<br> 💡 Vue 2：通过 <code>this.$parent</code> 获取父组件实例，或通过 <code>this.$children</code> 获取子组件实例。<br> 💡 Vue 3：通过 <code>ref</code> 引用子组件，直接访问其属性和方法。</li><li>Vue 3 组件支持多个 <code>v-model</code> 绑定和自定义属性名，父子之间的双向绑定更加灵活。</li></ul><p><strong>跨组件通信</strong></p><ul><li>Provide / Inject：父组件通过 <code>provide</code> 向后代组件传递数据，后代组件使用 <code>inject</code> 接收数据，适用于深层嵌套组件间的通信。</li><li>vuex：通过全局状态管理库 Vuex 共享状态，实现跨组件通信（vue2）。</li><li>pinia：Pinia 是 Vue 3 推荐的全局状态管理库，替代了 Vuex。</li><li>事件总线（Vue 2）：Vue 2 中可以通过<code>Event Bus</code>实现组件间的通信，但在 Vue 3 中不推荐使用。</li><li>全局事件处理器：通过在根组件$root或全局对象上监听事件，进行跨组件通信（Vue 3 推荐使用外部库，如 <code>mitt</code>）。</li></ul></details><h2 id="🔥vue-组件的生命周期" tabindex="-1">🔥Vue 组件的生命周期 <a class="header-anchor" href="#🔥vue-组件的生命周期" aria-label="Permalink to &quot;🔥Vue 组件的生命周期&quot;">​</a></h2><p>Vue 组件的生命周期是指组件从创建到销毁的整个过程，包括组件的初始化、渲染、更新和销毁等阶段。在Vue2和Vue3中，组件的生命周期有一些区别。</p><details class="details custom-block"><summary>Vue2</summary><ul><li><strong>创建阶段</strong></li></ul><p>1️⃣ <strong>beforeCreate</strong>：组件实例刚被创建，数据观测和事件/监听器设置之前。此时无法访问 <code>data</code>、<code>computed</code> 和 <code>methods</code> 等。<br> 2️⃣ <strong>created</strong>：组件实例已创建，数据观测、事件/监听器设置完成，此时可以访问 <code>data</code>、<code>computed</code> 和 <code>methods</code> 等，通常用于数据初始化。</p><ul><li><strong>挂载阶段</strong></li></ul><p>3️⃣ <strong>beforeMount</strong>：在挂载开始之前，模板已编译，<code>el</code> 和 <code>template</code> 已经确定，但尚未渲染。<br> 4️⃣ <strong>mounted</strong>：组件实例挂载到 DOM 上之后，此时可以访问和操作 DOM。</p><ul><li><strong>更新阶段</strong></li></ul><p>5️⃣ <strong>beforeUpdate</strong>：数据发生变化，DOM 尚未更新。可以在这里做一些数据处理，避免不必要的渲染。<br> 6️⃣ <strong>updated</strong>：数据变化，DOM 更新后调用。此时组件的 DOM 已经更新，可以访问和操作新的 DOM。</p><ul><li><strong>销毁阶段</strong></li></ul><p>7️⃣ <strong>beforeDestroy</strong>：组件实例销毁之前。可以在此阶段进行清理工作，例如移除事件监听器、定时器等。<br> 8️⃣ <strong>destroyed</strong>：组件实例销毁之后。此时，所有的事件监听器和子组件已被销毁。</p></details><details class="details custom-block"><summary>Vue3</summary><ul><li><strong>创建阶段</strong></li></ul><p>1️⃣ <strong>onBeforeMount</strong>：等效于 Vue 2 中的 <code>beforeMount</code>，在组件挂载之前调用。<br> 2️⃣ <strong>onMounted</strong>：等效于 Vue 2 中的 <code>mounted</code>，在组件挂载之后调用。</p><ul><li><strong>更新阶段</strong></li></ul><p>3️⃣ <strong>onBeforeUpdate</strong>：等效于 Vue 2 中的 <code>beforeUpdate</code>，在数据更新之前调用。<br> 4️⃣ <strong>onUpdated</strong>：等效于 Vue 2 中的 <code>updated</code>，在数据更新并渲染之后调用。</p><ul><li><strong>销毁阶段</strong></li></ul><p>5️⃣ <strong>onBeforeUnmount</strong>：等效于 Vue 2 中的 <code>beforeDestroy</code>，在组件卸载前调用。<br> 6️⃣ <strong>onUnmounted</strong>：等效于 Vue 2 中的 <code>destroyed</code>，在组件卸载后调用。</p></details><div class="tip custom-block"><p class="custom-block-title">setup与生命周期</p><p>setup 作为 Vue3 的 Composition API 的一部分,其内部函数的执行时机早于Mounted钩子。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, onMounted } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setup&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;onMounted&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line highlighted"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行结果:setup onMounted</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></div><h2 id="vue-组件在哪个生命周期发送-ajax-请求" tabindex="-1">Vue 组件在哪个生命周期发送 ajax 请求？ <a class="header-anchor" href="#vue-组件在哪个生命周期发送-ajax-请求" aria-label="Permalink to &quot;Vue 组件在哪个生命周期发送 ajax 请求？&quot;">​</a></h2><p>在 Vue中，接口请求一般放在 <code>created</code> 或 <code>mounted</code> 生命周期钩子中。</p><details class="details custom-block"><summary>参考答案</summary><p><strong>created 钩子</strong></p><ul><li><p>优点：<br> 💡 <strong>更快获取数据</strong>：能尽早获取服务端数据，减少页面加载时间。<br> 💡 <strong>SSR 支持</strong>：支持服务器端渲染（SSR），在 SSR 环境中不会受到限制。</p></li><li><p>缺点<br> 🙅 UI 未渲染时发起请求：如果需要操作 DOM 或渲染数据，可能导致闪屏问题</p></li></ul><p><strong>mounted 钩子</strong></p><ul><li><p>优点：<br> 💡 <strong>DOM 可用</strong>：适合需要操作 DOM 或渲染数据后再发起请求的情况，避免闪屏。</p></li><li><p>缺点<br> 🙅 <strong>请求延迟</strong>：数据请求会稍微延迟，增加页面加载时间。<br> 🙅 <strong>SSR 不支持</strong>：<code>mounted</code> 只在客户端执行，不适用于 SSR 环境。</p></li></ul></details><h2 id="vue-父子组件生命周期调用顺序" tabindex="-1">Vue 父子组件生命周期调用顺序 <a class="header-anchor" href="#vue-父子组件生命周期调用顺序" aria-label="Permalink to &quot;Vue 父子组件生命周期调用顺序&quot;">​</a></h2><h2 id="🔥v-show-和-v-if-的区别" tabindex="-1">🔥v-show 和 v-if 的区别 <a class="header-anchor" href="#🔥v-show-和-v-if-的区别" aria-label="Permalink to &quot;🔥v-show 和 v-if 的区别&quot;">​</a></h2><ul><li><strong>渲染方式：</strong><br> 💡v-if：条件为 true 时才会渲染元素，条件为 false 时销毁元素。<br> 💡v-show：始终渲染元素，只是通过 CSS 控制 <code>display 属性</code>来显示或隐藏。</li><li><strong>适用场景：</strong><br> 💡v-if：适用于条件变化不频繁的场景。<br> 💡v-show：适用于条件变化频繁的场景。</li></ul><h2 id="为何v-if和v-for不能一起使用" tabindex="-1">为何v-if和v-for不能一起使用？ <a class="header-anchor" href="#为何v-if和v-for不能一起使用" aria-label="Permalink to &quot;为何v-if和v-for不能一起使用？&quot;">​</a></h2><p><code>v-if</code> 和 <code>v-for</code> 不能直接一起使用的原因，主要是因为它们在 <strong>解析优先级</strong> 和 <strong>逻辑处理</strong> 上存在冲突。</p><details class="details custom-block"><summary>参考答案</summary><p>由于<code>v-for</code> 的解析优先级高于 <code>v-if</code>，同时使用 v-if 和 v-for，Vue 首先会循环创建所有dom元素，然后根据条件来判断是否渲染每个元素，这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差。其次，<code>v-for</code> 会为每个循环项创建一个新的作用域，而 <code>v-if</code> 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常。</p><p>为避免上述问题，vue官方推荐我们将 <code>v-if</code> 放到 <code>v-for</code> 外层，或者将 <code>v-if</code> 放置到 <code>v-for</code> 内部的单个节点上。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;show&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item in list&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> :key=&quot;item.id&quot;&gt;{{</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> item.name</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> }}&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;/div&gt;</span></span></code></pre></div></details><h2 id="computed-和-watch-有什么区别" tabindex="-1">computed 和 watch 有什么区别 <a class="header-anchor" href="#computed-和-watch-有什么区别" aria-label="Permalink to &quot;computed 和 watch 有什么区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th><code>computed</code></th><th><code>watch</code></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>用于计算基于响应式数据的值，并缓存结果</td><td>用于监听数据变化并执行副作用操作</td></tr><tr><td><strong>返回值</strong></td><td>返回计算结果</td><td>不返回值，执行副作用</td></tr><tr><td><strong>缓存机制</strong></td><td>只有在访问时才会计算，会缓存计算结果，仅当依赖变化时重新计算</td><td>数据变化时立即执行回调，不缓存，每次数据变化都会触发回调</td></tr><tr><td><strong>适用场景</strong></td><td>计算派生数据，避免不必要的重复计算</td><td>执行异步操作、处理副作用操作，如 API 请求</td></tr><tr><td><strong>性能</strong></td><td>性能较好，避免重复计算</td><td>每次数据变化时都会执行回调函数</td></tr></tbody></table><h2 id="🔥watch-和-watcheffect-的区别" tabindex="-1">🔥watch 和 watchEffect 的区别 <a class="header-anchor" href="#🔥watch-和-watcheffect-的区别" aria-label="Permalink to &quot;🔥watch 和 watchEffect 的区别&quot;">​</a></h2><p><code>watch</code> 和 <code>watchEffect</code> 都是 Vue 3 中用于响应式数据变化时执行副作用的 API，它们的使用场景和工作机制存在区别：</p><details class="details custom-block"><summary>参考答案</summary><ul><li><strong>依赖追踪方式</strong></li></ul><p><code>watch</code>：需要显式声明依赖，监听指定的数据源；可以监听多个数据源或进行深度监听。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { watch, reactive } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式声明监听的依赖</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`新值 \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newCount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} 老值 \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldCount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>watchEffect</code>：会自动追踪 <strong>作用域内所有的响应式依赖</strong>，不需要显式声明依赖。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { watchEffect, reactive } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Count 变化了: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动追踪 \`state.count\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ul><li><strong>执行时机</strong></li></ul><p><code>watch</code>：在监听的响应式数据变化后立即执行。</p><p><code>watchEffect</code>：在 <strong>组件挂载时</strong> 执行一次副作用，并在 <strong>依赖发生变化时</strong> 再次执行。</p><ul><li><strong>适用场景</strong></li></ul><p><code>watch</code>：适用于 <strong>监听特定数据</strong> 变化并执行副作用的场景，如 API 请求、保存操作等。适合需要 <strong>访问新值和旧值</strong> 进行比较的场景。</p><p><code>watchEffect</code>：不需要访问旧值，适用于 <strong>自动追踪多个响应式依赖</strong> 的副作用，如渲染、自动保存等。</p></details><blockquote><p>Vue官方API： <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect" target="_blank" rel="noreferrer">watchEffect</a></p></blockquote><h2 id="vue3-ref-和-reactive-如何选择" tabindex="-1">Vue3 ref 和 reactive 如何选择？ <a class="header-anchor" href="#vue3-ref-和-reactive-如何选择" aria-label="Permalink to &quot;Vue3 ref 和 reactive 如何选择？&quot;">​</a></h2><p><code>ref</code> 和 <code>reactive</code> 都是 Vue 3 中用来创建响应式数据的 API，他们的区别及使用场景如下。</p><details class="details custom-block"><summary>参考答案</summary><ul><li><p><strong>reactive的实现：</strong><br><code>reactive</code> 通过 <code>Proxy</code> 对对象或数组的每个属性进行深度代理，实现响应式。这种设计使得 <code>reactive</code> 能自动追踪所有嵌套属性的变化，但由于 <code>Proxy</code> 无法直接处理基本数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code>），因此，<code>reactive</code> 不适用于基本数据类型。</p></li><li><p><strong>ref的实现：</strong><br> 为了实现基本数据类型的响应式，Vue 设计了 <code>ref</code>。<code>ref</code> 会将基本数据类型封装为一个包含 <code>value</code> 属性的对象，通过 <code>getter</code> 和 <code>setter</code> 实现响应式依赖追踪和更新。当访问或修改 <code>ref.value</code> 时，Vue 内部会触发依赖更新。此外，对于复杂数据类型（如对象或数组），<code>ref</code> 的内部实现会直接调用 <code>reactive</code>，将复杂数据类型变为响应式。</p></li><li><p><strong>如何选择：</strong><br> 💡<strong>基本数据类型</strong>（如 <code>number</code>、<code>string</code>、<code>boolean</code>）：优先使用 <code>ref</code>。<br> 💡<strong>复杂数据类型</strong>（如对象、数组）：优先使用 <code>reactive</code>，因其操作更直观且无需依赖 <code>.value</code>。<br> 💡<strong>需动态替换整个数据对象</strong>：使用 <code>ref</code> 包裹复杂数据类型，方便直接替换 <code>ref.value</code> 的引用。</p></li></ul></details><h2 id="什么是动态组件-如何使用它" tabindex="-1">什么是动态组件？如何使用它？ <a class="header-anchor" href="#什么是动态组件-如何使用它" aria-label="Permalink to &quot;什么是动态组件？如何使用它？&quot;">​</a></h2><h2 id="什么是-slot-有什么应用场景" tabindex="-1">什么是 slot ，有什么应用场景？ <a class="header-anchor" href="#什么是-slot-有什么应用场景" aria-label="Permalink to &quot;什么是 slot ，有什么应用场景？&quot;">​</a></h2><h2 id="vue-项目可做哪些性能优化" tabindex="-1">Vue 项目可做哪些性能优化？ <a class="header-anchor" href="#vue-项目可做哪些性能优化" aria-label="Permalink to &quot;Vue 项目可做哪些性能优化？&quot;">​</a></h2><p>v-show keep-alive 异步组件 路由懒加载...</p><h2 id="什么是-nexttick-如何应用它" tabindex="-1">什么是 nextTick 如何应用它 <a class="header-anchor" href="#什么是-nexttick-如何应用它" aria-label="Permalink to &quot;什么是 nextTick 如何应用它&quot;">​</a></h2><h2 id="使用-vue3-composable-组合式函数-实现-usecount" tabindex="-1">使用 Vue3 Composable 组合式函数，实现 useCount <a class="header-anchor" href="#使用-vue3-composable-组合式函数-实现-usecount" aria-label="Permalink to &quot;使用 Vue3 Composable 组合式函数，实现 useCount&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// count 初始值是 0 ，每一秒 count 加 1</span></span></code></pre></div><h2 id="使用-vue3-composable-组合式函数-实现-userequest" tabindex="-1">使用 Vue3 Composable 组合式函数，实现 useRequest <a class="header-anchor" href="#使用-vue3-composable-组合式函数-实现-userequest" aria-label="Permalink to &quot;使用 Vue3 Composable 组合式函数，实现 useRequest&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可只考虑 get 请求</span></span></code></pre></div><h2 id="自定义组件如何实现-v-model" tabindex="-1">自定义组件如何实现 v-model <a class="header-anchor" href="#自定义组件如何实现-v-model" aria-label="Permalink to &quot;自定义组件如何实现 v-model&quot;">​</a></h2><h2 id="如何统一监听-vue-组件报错" tabindex="-1">如何统一监听 Vue 组件报错 <a class="header-anchor" href="#如何统一监听-vue-组件报错" aria-label="Permalink to &quot;如何统一监听 Vue 组件报错&quot;">​</a></h2><h2 id="vuex-中-mutation-和-action-有什么区别" tabindex="-1">Vuex 中 mutation 和 action 有什么区别？ <a class="header-anchor" href="#vuex-中-mutation-和-action-有什么区别" aria-label="Permalink to &quot;Vuex 中 mutation 和 action 有什么区别？&quot;">​</a></h2><h2 id="vuex-和-pinia-有什么区别" tabindex="-1">Vuex 和 Pinia 有什么区别？ <a class="header-anchor" href="#vuex-和-pinia-有什么区别" aria-label="Permalink to &quot;Vuex 和 Pinia 有什么区别？&quot;">​</a></h2><h2 id="vue-router-导航守卫能用来做什么" tabindex="-1">Vue-router 导航守卫能用来做什么？ <a class="header-anchor" href="#vue-router-导航守卫能用来做什么" aria-label="Permalink to &quot;Vue-router 导航守卫能用来做什么？&quot;">​</a></h2>`,46)]))}const u=i(n,[["render",l]]);export{k as __pageData,u as default};
