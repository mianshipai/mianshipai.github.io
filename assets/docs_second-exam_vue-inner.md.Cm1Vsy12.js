import{_ as l,c as p,a2 as e,j as i,a,t,o as h}from"./chunks/framework.YPpNXepj.js";const d="/assets/mvvm.CBEg-I1x.png",k="/assets/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A1.n7P2Pvid.png",r="/assets/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A2.JPP2WdDZ.png",o="/assets/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A3.Ci3ExrQr.png",V=JSON.parse('{"title":"Vue 原理","description":"","frontmatter":{},"headers":[],"relativePath":"docs/second-exam/vue-inner.md","filePath":"docs/second-exam/vue-inner.md"}'),E={name:"docs/second-exam/vue-inner.md"},c={class:"details custom-block"},g={class:"details custom-block"};function u(n,s,y,m,v,F){return h(),p("div",null,[s[17]||(s[17]=e(`<h1 id="vue-原理" tabindex="-1">Vue 原理 <a class="header-anchor" href="#vue-原理" aria-label="Permalink to &quot;Vue 原理&quot;">​</a></h1><p>国内面试，大厂必考原理。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>目标<strong>不在</strong>中大厂的同学，可以略过这一节。</li><li>对 Vue 使用尚不熟练的同学，不要在此花费太多精力，先熟悉使用再说。</li></ol></div><h2 id="什么是-mvvm" tabindex="-1">什么是 MVVM <a class="header-anchor" href="#什么是-mvvm" aria-label="Permalink to &quot;什么是 MVVM&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p><strong>MVVM（Model-View-ViewModel）</strong> 是一种用于构建用户界面的架构模式，用于现代的前端开发框架（Vue、Angular）。它通过 <strong>数据绑定</strong> 和 <strong>视图模型</strong> 提供了高效的 UI 更新和数据同步机制。</p><p>MVVM 模式主要由 <code>Model</code> （模型）、 <code>View</code> （视图）、 <code>ViewModel</code> （视图模型）三个部分组成。</p><ul><li><code>Model</code>表示程序的核心数据和业务逻辑，它不关心用户界面，只负责数据的获取、存储和处理，并提供与外界交互的接口。</li><li><code>View</code>负责展示数据和用户交互，简单来说他就是我们看到的UI 组件或 HTML 页面。</li><li><code>ViewModel</code>是连接 <code>View</code> 和 <code>Model</code> 的桥梁，它不直接操作视图或模型，而是通过数据绑定将两者连接起来。</li></ul><p>参考下面的示例：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;input v-model=&quot;message&quot;/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;p&gt;{{ computedValue }}&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, MVVM!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> computedValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;用户输入值变为:&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message.value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>上述代码展示了一个输入框，当用户输入内容的时候，输入框下面的计算值会随之变化。在这个示例中， <code>message</code> 变量属于 <code>Model</code> ，它包含了应用的核心数据。输入框与页面展示就属于View，负责展示数据和用户交互。 <code>computed</code> 和 <code>v-model语法糖</code> 作为 <code>ViewModel</code> ，用于更新视图和数据。</p><p><img src="`+d+`" alt=""></p></details><h2 id="什么是-vdom-它和-dom-有什么关系" tabindex="-1">什么是 VDOM 它和 DOM 有什么关系 <a class="header-anchor" href="#什么是-vdom-它和-dom-有什么关系" aria-label="Permalink to &quot;什么是 VDOM 它和 DOM 有什么关系&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>页面的所有元素、属性和文本都通过 <code>DOM</code> 节点表示， <code>VDOM（Virtual DOM，虚拟 DOM）</code> 是DOM渲染的一种优化，它是一个内存中的虚拟树，是真实 DOM 的轻量级 JavaScript 对象表示。</p><p>VDOM主要用于优化 UI 渲染性能，它的工作流程大致如下：</p><ul><li>1️⃣<strong>创建虚拟 DOM</strong>：当组件的状态或数据发生变化时，Vue 会重新生成虚拟 DOM。</li><li>2️⃣<strong>比较虚拟 DOM 和真实 DOM</strong>：Vue 使用一种高效的算法来比较新旧虚拟 DOM 的差异（即 diff 算法）。</li><li>3️⃣<strong>更新 DOM</strong>：根据差异更新真实的 DOM，仅修改有变化的部分，而不是重新渲染整个 DOM 树。</li></ul></details><h2 id="手写-vnode-对象-表示如下-dom-节点" tabindex="-1">手写 VNode 对象，表示如下 DOM 节点 <a class="header-anchor" href="#手写-vnode-对象-表示如下-dom-节点" aria-label="Permalink to &quot;手写 VNode 对象，表示如下 DOM 节点&quot;">​</a></h2><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;container&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x1.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;hello&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p>如果你还不熟悉 <code>虚拟 DOM</code> 和 <code>渲染函数</code> 的概念的话，请先学习<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html" target="_blank" rel="noreferrer">vue的渲染机制</a></p></blockquote><details class="details custom-block"><summary>参考答案</summary><p>Vue 模板会被预编译成<strong>虚拟 DOM 渲染函数</strong>，我们也可以直接手写<strong>渲染函数</strong>，在处理高度动态的逻辑时，渲染函数相比于模板更加灵活，因为我们可以完全地使用 <code>JavaScript</code> 来构造我们想要的 <code>vnode</code> 。</p><p>Vue 提供了一个 <code>h()</code> 函数用于创建 <code>vnodes</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, props, children)</span></span></code></pre></div><ul><li><code>type</code>: 表示要渲染的节点类型（例如 HTML 标签名或组件）。</li><li><code>props</code>: 一个对象，包含该节点的属性（例如 <code>class</code>、<code>style</code>、<code>src</code> 等）。</li><li><code>children</code>: 子节点，可以是文本内容、数组或者其他 VNode。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { h } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        class: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;img&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          src: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;x1.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></details><h2 id="vue-组件初始化的各个阶段都做了什么" tabindex="-1">Vue 组件初始化的各个阶段都做了什么？ <a class="header-anchor" href="#vue-组件初始化的各个阶段都做了什么" aria-label="Permalink to &quot;Vue 组件初始化的各个阶段都做了什么？&quot;">​</a></h2><h2 id="vue-如何实现双向数据绑定" tabindex="-1">Vue 如何实现双向数据绑定？ <a class="header-anchor" href="#vue-如何实现双向数据绑定" aria-label="Permalink to &quot;Vue 如何实现双向数据绑定？&quot;">​</a></h2>`,13)),i("details",c,[s[3]||(s[3]=e("<summary>参考答案</summary><p>Vue 实现双向数据绑定的核心是通过<strong>响应式系统</strong>的 <strong>数据劫持</strong>和 <strong>观察者模式</strong>来实现的。</p><p>🎯 <strong>数据劫持</strong></p><p>Vue 2.x 使用 <code>Object.defineProperty</code> 对数据对象的每个属性递归添加 <code>getter/setter</code> ，当数据的属性被访问时，触发 <code>getter</code> ，当属性被修改时，触发 <code>setter</code> 通知视图进行更新。通过这种方式，Vue 可以监控数据的变化，并在数据变化时通知视图更新。</p><blockquote><p>Vue 3.x 使用 Proxy通过代理对象拦截整个对象的操作，无需递归初始化所有属性，性能更好。</p></blockquote><p>🎯 <strong>观察者模式</strong></p><p>Vue 的响应式系统通过 <strong>观察者模式</strong> 来实现数据与视图的同步更新，简化的流程如下：</p>",7)),i("ul",null,[i("li",null,[s[0]||(s[0]=i("strong",null,"依赖收集",-1)),s[1]||(s[1]=a("：当 Vue 组件的视图模板渲染时，它会读取数据对象的属性（例如 ")),i("code",null,t(n.message),1),s[2]||(s[2]=a("）。在读取属性时，getter方法会将视图组件与该数据属性建立依赖关系。"))])]),s[4]||(s[4]=e('<p><img src="'+k+'" alt=""></p><ul><li><strong>观察者（Watcher）</strong>：每个依赖的数据都会对应一个观察者。观察者的作用是监听数据的变化，一旦数据发生变化，观察者会收到通知，进而触发视图的更新。</li></ul><p><img src="'+r+'" alt=""></p><ul><li><strong>通知视图更新（Notify View Update）</strong>：当数据通过 <code>setter</code> 修改时，Vue 会触发相应的观察者，通知相关的视图组件更新。</li></ul><p><img src="'+o+'" alt=""></p><p>通过这种方式，Vue 可以监控数据的变化，并在数据变化时通知视图更新。</p>',6))]),s[18]||(s[18]=i("h2",{id:"vue-模板编译的过程",tabindex:"-1"},[a("Vue 模板编译的过程 "),i("a",{class:"header-anchor",href:"#vue-模板编译的过程","aria-label":'Permalink to "Vue 模板编译的过程"'},"​")],-1)),i("details",g,[s[15]||(s[15]=i("summary",null,"参考答案",-1)),i("p",null,[s[5]||(s[5]=a("Vue 的模板编译过程是将开发者编写的模板语法（例如 ")),i("code",null,t(n.message),1),s[6]||(s[6]=a(" 和 ")),s[7]||(s[7]=i("code",null,"v-bind",-1)),s[8]||(s[8]=a(" 等）转换为 JavaScript 代码的过程。它主要分为三个阶段：")),s[9]||(s[9]=i("strong",null,"模板解析",-1)),s[10]||(s[10]=a("、")),s[11]||(s[11]=i("strong",null,"AST优化",-1)),s[12]||(s[12]=a(" 和 ")),s[13]||(s[13]=i("strong",null,"代码生成",-1)),s[14]||(s[14]=a("："))]),s[16]||(s[16]=e(`<p>1️⃣ <strong>模板解析</strong></p><p>Vue 使用其解析器将 HTML 模板转换为 <strong>抽象语法树（AST）</strong>。在这个阶段，Vue 会分析模板中的标签、属性和指令，生成一颗树形结构。每个节点表示模板中的一个元素或属性。</p><p>如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt; </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p &gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            message</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } &lt; /p&gt; &lt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button v - on: click = &quot;handleClick&quot; &gt; 点击 &lt; /button&gt; &lt; /</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div &gt;</span></span></code></pre></div><p>被解析成的 AST 类似于下面的结构：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类型：1 表示元素节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 元素的标签名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [ </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点（嵌套的 HTML 元素）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            type: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点是一个元素节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            children: [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                type: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2 表示插值表达式节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                expression: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 表达式 &#39;message&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            type: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 另一个元素节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            events: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 事件监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                click: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;handleClick&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 绑定 click 事件，执行 handleClick 方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            children: [{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                type: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 文本节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                text: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;点击&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 按钮文本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>2️⃣ <strong>AST优化</strong></p><p>Vue 在生成渲染函数前，会对 AST 进行优化。优化的核心目标是标记 <strong>静态节点</strong>，在渲染时，Vue 可以跳过这些静态节点，提升性能。</p><blockquote><p><strong>静态节点</strong>指所有的渲染过程中都不变化的内容，比如 <code>某个div标签内的静态文本</code></p></blockquote><p>在 <code>vue3</code> 中，如果一个节点及其子树都不依赖于动态数据，那么该节点会被提升到渲染函数外部（静态提升），仅在组件初次渲染时创建。</p><p>3️⃣ <strong>代码生成</strong></p><p>生成渲染函数是编译的最终阶段，这个阶段会将优化后的 AST 转换成 JavaScript 渲染函数。</p><p>例如，像这样的模板：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>最终会生成类似这样的渲染函数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>渲染函数的返回值是一个 <code>虚拟 DOM（VDOM）树</code> ，Vue 会根据 <code>虚拟 DOM</code> 来更新实际的 <code>DOM</code> 。由于 <code>渲染函数</code> 被 Vue 的响应式系统包裹，当数据发生变化时，渲染函数会被重新执行生成新的虚拟 DOM，因此页面也会实时更新。</p>`,17))]),s[19]||(s[19]=e('<h2 id="vue-响应式原理" tabindex="-1">Vue 响应式原理 <a class="header-anchor" href="#vue-响应式原理" aria-label="Permalink to &quot;Vue 响应式原理&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>Vue 的响应式原理在 2.x 和 3.x 中有所不同，分别基于 <code>Object.defineProperty</code> 和 <code>Proxy</code> 实现。</p><p>🎯 <strong>Vue 2.x 的实现 ( <code>Object.defineProperty</code> )</strong></p><p><code>Object.defineProperty</code> 支持 IE9 及以上版本，兼容性非常好。它会递归遍历对象，对每个属性单独设置 <code>getter</code> 和 <code>setter</code> ，但也存在以下局限性：</p><ul><li><strong>无法监听动态属性增删</strong><br> Vue 2.x 在新增或删除对象属性时不会触发视图更新，需通过 <code>Vue.set</code> 或 <code>Vue.delete</code> 手动处理。</li><li><strong>数组监听受限</strong><br> 无法直接监听数组索引的修改（如 <code>arr[0] = 1</code> ）和 <code>length</code> 变化，因此 Vue 2.x 重写了数组的一些方法来解决这一问题。</li><li><strong>性能开销较大</strong><br> 需要递归地为每个属性设置 <code>getter</code> 和 <code>setter</code> ，对深层嵌套的对象和大型数组性能较差。</li><li><strong>不支持 Map/Set 等数据结构</strong><br> 只能代理普通对象和数组，不能处理像 <code>Map</code> 、 <code>Set</code> 等复杂数据结构。</li></ul><p>🚀 <strong>Vue 3.x 的实现 ( <code>Proxy</code> )</strong></p><p>为了解决 Vue 2.x 中的这些问题，Vue 3.x 采用了 <code>Proxy</code> ，带来了更优的性能和更全面的响应式支持：</p><ul><li><strong>动态属性增删支持</strong><br><code>Proxy</code> 可以直接代理整个对象，因此可以监听属性的动态增删，不再需要手动操作。</li><li><strong>完美支持数组和索引修改</strong><br><code>Proxy</code> 能够监听数组索引的修改（如 <code>arr[0] = 1</code> ）以及 <code>length</code> 变化，避免了 Vue 2.x 中的重写数组方法。</li><li><strong>性能更优</strong><br><code>Proxy</code> 采用懒代理模式，只有在访问属性时才会递归代理子对象，避免了递归遍历的性能开销。</li><li><strong>支持更多数据结构</strong><br> 除了普通对象和数组， <code>Proxy</code> 还可以代理 <code>Map</code> 、 <code>Set</code> 等数据结构，提供了更强大的响应式能力。</li></ul><table tabindex="0"><thead><tr><th>特性</th><th><code>Object.defineProperty</code> <br>（Vue 2）</th><th><code>Proxy</code> <br>（Vue 3）</th></tr></thead><tbody><tr><td>动态属性增删</td><td>❌ 不支持（需 <code>Vue.set</code> / <code>Vue.delete</code> ）</td><td>✅ 支持</td></tr><tr><td>数组索引修改</td><td>❌ 需重写方法（如 <code>push</code> ）</td><td>✅ 直接监听</td></tr><tr><td>性能</td><td>⚠️ 递归初始化所有属性，性能较差</td><td>✅ 惰性代理，按需触发，性能更优</td></tr><tr><td>数据结构支持</td><td>❌ 仅普通对象/数组</td><td>✅ 支持 <code>Map</code> 、 <code>Set</code> 等</td></tr><tr><td>兼容性</td><td>✅ 支持 IE9+</td><td>❌ 不支持 IE</td></tr><tr><td>实现复杂度</td><td>⚠️ 需递归遍历对象，代码冗余</td><td>✅ 统一拦截，代码简洁</td></tr></tbody></table></details><h2 id="为何-v-for-需要使用-key" tabindex="-1">为何 v-for 需要使用 key <a class="header-anchor" href="#为何-v-for-需要使用-key" aria-label="Permalink to &quot;为何 v-for 需要使用 key&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>在 Vue.js 中，使用 <code>v-for</code> 渲染列表时，添加 key 属性是一个重要的最佳实践。</p><ul><li><strong>提高性能</strong>：当 Vue 更新视图时，它会根据 <code>key</code> 来识别哪些元素被修改、添加或移除。如果没有 <code>key</code>，Vue 会依赖其默认的算法（基于元素的位置）来比较元素，这样可能导致不必要的 DOM 操作。使用 <code>key</code> 后，Vue 能精确地找到每个项，从而减少不必要的 DOM 重排和重绘，提升性能。</li><li><strong>保持组件状态</strong>：如果渲染的是一个组件（而不是普通的 DOM 元素），使用 <code>key</code> 可以确保组件在渲染更新时保持正确的状态。例如，如果列表中有表单输入框，每个输入框都有自己的状态，使用 <code>key</code> 可以确保输入框状态不会因列表排序或元素移除而丢失。</li><li><strong>避免渲染错误</strong>：key 的存在可以帮助 Vue 确保在列表更新时，元素的顺序和内容保持稳定，避免出现不稳定的渲染或顺序错乱。</li></ul></details><h2 id="vue-diff-算法的过程" tabindex="-1">Vue diff 算法的过程 <a class="header-anchor" href="#vue-diff-算法的过程" aria-label="Permalink to &quot;Vue diff 算法的过程&quot;">​</a></h2><p>使用最长递增子序列算法...</p><p>@石小石 将于 2025.02.20 之前提交答案。</p><h2 id="vue3-diff-算法做了哪些优化" tabindex="-1">Vue3 diff 算法做了哪些优化？ <a class="header-anchor" href="#vue3-diff-算法做了哪些优化" aria-label="Permalink to &quot;Vue3 diff 算法做了哪些优化？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ul><li>静态标记与动态节点的区分 Vue3引入了 <code>静态标记（Static Marking）</code> 机制，通过在模板编译阶段为静态节点添加标记，避免了对这些节点的重复比较。这使得Vue3能够更高效地处理静态内容，减少不必要的DOM操作。</li><li>双端对比策略 Vue3的Diff算法采用了双端对比策略，即从新旧节点的头部和尾部同时开始比较，快速定位无序部分。这种策略显著减少了全量对比的复杂度，提升了性能。</li><li>最长递增子序列（LIS）优化 在处理节点更新时，Vue3利用最长递增子序列（LIS）算法来优化对比流程。通过找到新旧节点之间的最长递增子序列，Vue3可以减少不必要的DOM操作，从而提高更新效率。</li><li>事件缓存与静态提升 事件缓存：Vue3将事件缓存为静态节点，避免每次渲染时重新计算事件处理逻辑，从而减少性能开销。 静态提升：对于不参与更新的元素，Vue3将其提升为静态节点，仅在首次创建时进行处理，后续不再重复计算。</li><li>类型检查与属性对比 Vue3在Diff算法中增加了类型检查和属性对比功能。如果节点类型不同，则直接替换；如果类型相同，则进一步对比节点的属性，生成更新操作。</li><li>动态插槽的优化 Vue3对动态插槽进行了优化，通过动态节点的类型化处理，进一步提升了Diff算法的效率</li></ul></details><h2 id="vue-diff-算法和-react-diff-算法的区别" tabindex="-1">Vue diff 算法和 React diff 算法的区别 <a class="header-anchor" href="#vue-diff-算法和-react-diff-算法的区别" aria-label="Permalink to &quot;Vue diff 算法和 React diff 算法的区别&quot;">​</a></h2><p>@石小石 将于 2025.02.20 之前提交答案。</p><h2 id="简述-vue-组件异步更新的过程" tabindex="-1">简述 Vue 组件异步更新的过程 <a class="header-anchor" href="#简述-vue-组件异步更新的过程" aria-label="Permalink to &quot;简述 Vue 组件异步更新的过程&quot;">​</a></h2><p>队列</p><h2 id="vue-组件是如何渲染和更新的" tabindex="-1">Vue 组件是如何渲染和更新的 <a class="header-anchor" href="#vue-组件是如何渲染和更新的" aria-label="Permalink to &quot;Vue 组件是如何渲染和更新的&quot;">​</a></h2><h2 id="如何实现-keep-alive-缓存机制" tabindex="-1">如何实现 keep-alive 缓存机制 <a class="header-anchor" href="#如何实现-keep-alive-缓存机制" aria-label="Permalink to &quot;如何实现 keep-alive 缓存机制&quot;">​</a></h2><p>@石小石 将于 2025.02.20 之前提交答案。</p><h2 id="为何-ref-需要-value-属性" tabindex="-1">为何 ref 需要 value 属性 <a class="header-anchor" href="#为何-ref-需要-value-属性" aria-label="Permalink to &quot;为何 ref 需要 value 属性&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>Vue 3 中， <code>ref</code> 之所以需要 <code>.value</code> 属性，主要是因为 Vue 3 使用 <code>Proxy</code> 实现响应式。 <code>Proxy</code> 对对象或数组的每个属性进行深度代理，因此可以追踪嵌套属性的变化。而 <code>Proxy</code> 无法直接处理基本数据类型（如 <code>number</code> 、 <code>string</code> 、 <code>boolean</code> ），这使得 <code>reactive</code> 无法用于基本数据类型。为了实现基本数据类型的响应式，Vue 设计了 <code>ref</code> ，它将基本数据类型封装为一个包含 <code>value</code> 属性的对象，并通过 <code>getter</code> 和 <code>setter</code> 进行依赖追踪和更新。当访问或修改 <code>ref.value</code> 时，Vue 会触发依赖更新。</p></details>',18))])}const D=l(E,[["render",u]]);export{V as __pageData,D as default};
